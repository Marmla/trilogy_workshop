---
title: "Trilogy Workshop"
author: "Josh Hagedorn" 
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide
    theme:
      version: 5
      bootswatch: flatly
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(tidyverse)
```

# Load packages and trilogy data sets

Let's start by loading the materials we'll need:

-   the R packages we'll use
-   the `trilogy` datasets

The main package we'll use is the [tidyverse](https://www.tidyverse.org/), which is actually a collection of R packages with consistent design philosophy, grammar, and data structures.

To pull the current versions of the datasets, we'll follow the steps outlined in the [Getting Started \> Use in Reproducible Research](https://github.com/j-hagedorn/trilogy/blob/master/docs/vignettes/getting_started.md#use-in-reproducible-research) vignette. That's why you'll see a long, alphanumeric code in the links below, specifying precisely what version of the data is being used.

```{r load}
tmi <- read_csv("https://raw.githubusercontent.com/j-hagedorn/trilogy/d57c2cefd0b216c8ce5c251f618c3e931c732d0a/data/tmi.csv")
atu_df <- read_csv("https://raw.githubusercontent.com/j-hagedorn/trilogy/d57c2cefd0b216c8ce5c251f618c3e931c732d0a/data/atu_df.csv")
atu_seq <- read_csv("https://raw.githubusercontent.com/j-hagedorn/trilogy/d57c2cefd0b216c8ce5c251f618c3e931c732d0a/data/atu_seq.csv")
aft <- read_csv("https://raw.githubusercontent.com/j-hagedorn/trilogy/d57c2cefd0b216c8ce5c251f618c3e931c732d0a/data/aft.csv")
```

This allows us to explicitly reference a version of the data so that any research we do can be precisely replicated by others. For instance, if you wanted to pull an old (and not yet cleaned-up) version of the `aft` dataset, you'd just need to go back in the GitHub history and run the following:

```{r old_aft, eval=FALSE, include=TRUE}
old_aft <- read_csv("https://raw.githubusercontent.com/j-hagedorn/trilogy/f0fb12d108734847114f17980b05686a26305e38/data/aat.csv")
```

# Summary Statistics

The table below shows the distinct count of motifs and tale types in *Trilogy* datasets. 

```{r overlaps}

x <- 
  atu_seq %>% 
  # Get all tale IDs and motif IDs within them
  select(motif,atu_id) %>% 
  mutate(in_atu_seq = T) %>%
  # Pull in all tale IDs present in annotated tales.
  # Note that counting motifs in annotated tales assumes 
  # that each tale has each motif in the canonical sequence.
  left_join(
    aft %>% select(atu_id) %>% mutate(in_aft = T),
    by = "atu_id"
  ) %>%
  distinct(motif, in_atu_seq, in_aft) %>%
  mutate(in_aft = if_else(is.na(in_aft),F,T)) %>%
  # Don't keep multiple rows per motif, count as present (i.e. 'TRUE')
  group_by(motif, in_atu_seq) %>%
  filter(in_aft == max(in_aft))

m <-
  tmi %>%
  select(motif = id) %>%
  distinct(motif) %>%
  left_join(x, by = "motif") %>%
  mutate(
    in_tmi = T,
    in_atu_seq = if_else(is.na(in_atu_seq),F,in_atu_seq),
    in_aft = if_else(is.na(in_aft),F,in_aft)
  ) 

m_sum <-
  m %>%
  summarise(
    in_tmi =     sum(in_tmi),
    in_atu_seq = sum(in_atu_seq),
    in_aft =     sum(in_aft)
  ) %>%
  mutate(unit = "motifs")
  
t <-
  atu_df %>%
  distinct(atu_id) %>%
  mutate(in_atu_df = T) %>%
  left_join(
    atu_seq %>% 
      distinct(atu_id) %>%
      mutate(in_atu_seq = T),
    by = "atu_id"
  ) %>%
  left_join(
    aft %>%
      distinct(atu_id) %>%
      mutate(in_aft = T),
    by = "atu_id"
  ) %>%
  mutate(
    in_atu_seq = if_else(is.na(in_atu_seq),F,in_atu_seq),
    in_aft = if_else(is.na(in_aft),F,in_aft)
  ) 

t_sum <-
  t %>%
  summarise(
    in_atu_df =  sum(in_atu_df),
    in_atu_seq = sum(in_atu_seq),
    in_aft =     sum(in_aft)
  ) %>%
  mutate(unit = "tale types")
  
m_sum %>%
  bind_rows(t_sum) %>%
  select(
    unit, tmi = in_tmi, 
    atu_df = in_atu_df, atu_seq = in_atu_seq, aft = in_aft
  ) %>%
  rmarkdown::paged_table()

rm(m); rm(m_sum); rm(t); rm(t_sum)

```

Note that motifs do not exist in `atu_df` or `atu_combos`, because those datasets contain one row per `atu_id`. Similarly, tale types (`atu_id`s) do not exist in `tmi`, because that dataset contains one row per motif.


#### Intersections of Motifs within Trilogy Datasets

Below is an [upset plot](https://doi.org/10.1109/TVCG.2014.2346248) showing the intersection of discrete motifs across the various datasets which comprise the *Trilogy*.

```{r upset_motif}
library(UpSetR)

motif_lists <- 
  list(
    tmi = tmi %>% distinct(id) %>% .$id, 
    atu_seq = atu_seq %>% distinct(motif) %>% .$motif, 
    aft = x %>% filter(in_aft) %>% .$motif
  )

upset(
  fromList(motif_lists), 
  order.by = "freq",
  mainbar.y.label = "Intersection Size", 
  sets.x.label = "Motifs per Dataset"
)

rm(x); rm(motif_lists)

unjoined_motifs <-
  atu_seq %>% 
  select(motif) %>%
  distinct() %>%
  anti_join(tmi, by = c("motif" = "id"))
```

Observations:

- The majority of motifs from the `tmi` are not present in the ATU (i.e. `atu_seq`).  Specifically, 42,457 of the `r n_distinct(tmi$id)` motifs in the `tmi` (`r round(42457/n_distinct(tmi$id) * 100, digits = 1)`%) are __not__ present in the ATU.  This means that the tale types from the ATU make use of only `r 100 - round(42457/n_distinct(tmi$id) * 100, digits = 1)`% of the available motifs from the TMI.
- Of the motifs which are present in the ATU (`atu_seq`), most (n = `r 2939 + 30`/`r n_distinct(atu_seq$motif)`) do __not__ have corresponding annotated texts in the `aft`.
- There are 826 motifs present in the tale types represented by the `aft`.  This is a minuscule `r round(826/n_distinct(tmi$id) * 100, digits = 1)`% of the total available motifs in the `tmi`.
- There are a small number of odd instances (n = 34), where a motif ID is present in `atu_seq`, but not in the `tmi`.  In 4 of these instances, there is one or more corresponding tale text in the `aft` which contains a non-`tmi` motif.^[The unmatched motif IDs include: `r paste(unjoined_motifs$motif, collapse = ", ")`. One can inspect these individually and compare them to the `tmi` and find that there are similar motifs that don't quite match.  For instance, there is no "F661.1.1", but there is a "F661.11", or "Skillful Archer Uses Arrow As Boomerang".]

---

#### Intersections of Tale Types within Trilogy Datasets

```{r upset_types}
type_lists <- 
  list(
    atu_df = atu_df %>% distinct(atu_id) %>% .$atu_id, 
    atu_seq = atu_seq %>% distinct(atu_id) %>% .$atu_id, 
    aft = aft %>% distinct(atu_id) %>% .$atu_id
  )
upset(
  fromList(type_lists), 
  order.by = "freq",
  mainbar.y.label = "Intersection Size", 
  sets.x.label = "Tale Types per Dataset"
)
rm(type_lists)
```

Observations:

- Not all `atu_id`s in `atu_df` are in `atu_seq`, because some of the tale summaries from `atu_df` do not reference any motif IDs.^[Motifs are extracted from the tale summaries present in the ATU [using the code here](https://github.com/j-hagedorn/trilogy/blob/d57c2cefd0b216c8ce5c251f618c3e931c732d0a/fetch/fetch_taletypes.R#L100-L127).  An example of a tale summary without identified motif IDs is ATU 1342: "*During a cold winter, a satyr (wood spirit) meets a man (boy) who is cold and accommodates him in his cave. The satyr watches the man blowing in his hand and is told that in this way he wants to warm his numb fingers. When the satyr serves up a meal, his guest blows on the food and explains that he wants to cool it. The satyr is afraid of this strange human behavior, blowing hot and cold in the same manner, and chases the man away.*"]. Specifically, 597 tale types in the ATU do not have distinct motif IDs identified. 
- This means that an `atu_id` can be present in `atu_df` and in `aft`, but not be included in `atu_seq`, which means the text version of the tale cannot be referenced against an available list of motifs.  Fortunately, this only applies to 8 tale types.
- Most of the tale types from the ATU (`atu_df` and `atu_seq`) are not present in the `aft`.  This underscores the need for more annotated texts.

```{r anti_joins}
un <-
  aft %>%
  select(atu_id) %>%
  distinct() %>%
  anti_join(atu_seq %>% select(atu_id) %>% distinct(), by = "atu_id")
```

------------------------------------------------------------------------

# Motifs

The `tmi` is comprised of `r n_distinct(tmi$id)` distinct motifs.[^1] It is grouped into `r n_distinct(tmi$chapter_id)` chapters, including: *`r paste(unique(tmi$chapter_name), collapse = ", ")`*.

[^1]: Recall that Yarlott and Finlayson (2016) counted "46,248 motifs and sub-motifs, 41,796 of which have references to tales or tale types." While there is a difference in the total count of motifs, it is minimal, and it is unclear what they mean by sub-motifs.

## Hierarchy {.tabset .tabset-pills}

Under the chapter level, it has multiple nested levels of groups, which are named as follows:

-   `level_0` = What Thompson labelled 'Grand divisions', sections divisible by 100.
-   `level_1` = Smaller divisions end with '0', These are defined at intervals of 10.
-   `level_2`-`level_6` = Various sections with multiple layers of subdivisions

### Flat format

The excerpt below shows how this hierarchy structure is represented in the 'flat' dataset:

```{r, layout="l-body-outset"}
tmi %>%
  filter(level_2 == "B122") %>%
  select(chapter_id,id,motif_name,level,starts_with("level_")) %>%
  select(-level_5,-level_6) %>%
  arrange(id) %>%
  rmarkdown::paged_table()
```

------------------------------------------------------------------------

### Distribution by level

The most populated level of the index (i.e. '3') is that of the initial *subdivision*, indicating that there are frequently no splits made in the motif identified. While the index structure would allow for each subsequent level (i.e. levels 4 - 6+) to have increasing numbers of more finely grained motifs, these either do not exist or have not been filled in.

```{r}
tmi %>%
  ggplot(aes(x = level)) +
  geom_histogram(stat="count") +
  theme_minimal() + 
  theme(plot.title.position = "plot") +
  labs(
    title = "Most motifs are in the subdivisions",
    subtitle = "From chapters (level 0) through subdivisions (levels 3-6)",
    x = "Depth within index",
    y = "Distinct motif entries"
  )
```

------------------------------------------------------------------------

### Gaps

Note that some motifs are not fit into the hierarchical level format (i.e. `level = NA`). This occurs when there is a zero indicator at one of the decimal indices, since this creates a break in the hierarchical structure. For instance, in the "B122" section, we find B122.1 as a parent motif for B122.1.1-2, but there is no B122.0 to serve as a parent for B122.0.1.

The table below shows how many motifs (i.e. `n_motifs`) are in each chapter, and each level (*if you expand the row*).

```{r tmi_summary_tbl}
library(reactable)
tmi %>%
  group_by(chapter_name,level) %>%
  summarize(n_motifs = n_distinct(id)) %>%
  reactable(
    groupBy = c("chapter_name"),
    columns = list(
      level = colDef(
        aggregate = "count",
        format = list(
          aggregated = colFormat(suffix = " levels")
        )
      ),
      n_motifs = colDef(aggregate = "sum")
    )
  )
```

```{r}
summary_df <-
  tmi %>%
  group_by(chapter_id,chapter_name,level_0,level_1,level_2,level_3) %>%
  summarize(n = n()) %>% 
  ungroup() %>%
  left_join(tmi %>% select(id,level_0_name = motif_name), by = c("level_0" = "id")) %>%
  left_join(tmi %>% select(id,level_1_name = motif_name), by = c("level_1" = "id")) %>%
  left_join(tmi %>% select(id,level_2_name = motif_name), by = c("level_2" = "id")) %>%
  left_join(tmi %>% select(id,level_3_name = motif_name), by = c("level_3" = "id")) %>%
  select(
    starts_with("chapter_"),starts_with("level_0"),
    starts_with("level_1"),starts_with("level_2"),starts_with("level_3"),n
  )
```

------------------------------------------------------------------------

# Tale Types

-   Given the 'type = motif string with equiprobable motifs in forkings' working hypothesis, 68245 strings is shocking.  Based on the 2250 ATU type strings, how many possible strings (ways to tell a tale) exist? Explain reasoning
-   average number of motifs which constitute a type -- the average number of forkings (if they can be calculated)

------------------------------------------------------------------------

# Annotated Tales

-   Joining together data sets by primary key
-   First analysis: coverage of motif index in the tale type index
-   Visualization
-   Adding citations
-   Where to go next?

------------------------------------------------------------------------






