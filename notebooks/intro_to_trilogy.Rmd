---
title: "Trilogy Workshop"
author: "Josh Hagedorn" 
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide
    theme:
      version: 5
      bootswatch: flatly
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(tidyverse)
```

# Load packages and trilogy data sets

Let's start by loading the materials we'll need:

-   the R packages we'll use
-   the `trilogy` datasets

The main package we'll use is the [tidyverse](https://www.tidyverse.org/), which is actually a collection of R packages with consistent design philosophy, grammar, and data structures.

To pull the current versions of the datasets, we'll follow the steps outlined in the [Getting Started \> Use in Reproducible Research](https://github.com/j-hagedorn/trilogy/blob/master/docs/vignettes/getting_started.md#use-in-reproducible-research) vignette. That's why you'll see a long, alphanumeric code in the links below, specifying precisely what version of the data is being used.

```{r load}
tmi <- read_csv("https://raw.githubusercontent.com/j-hagedorn/trilogy/d57c2cefd0b216c8ce5c251f618c3e931c732d0a/data/tmi.csv")
atu_df <- read_csv("https://raw.githubusercontent.com/j-hagedorn/trilogy/d57c2cefd0b216c8ce5c251f618c3e931c732d0a/data/atu_df.csv")
atu_seq <- read_csv("https://raw.githubusercontent.com/j-hagedorn/trilogy/d57c2cefd0b216c8ce5c251f618c3e931c732d0a/data/atu_seq.csv")
aft <- read_csv("https://raw.githubusercontent.com/j-hagedorn/trilogy/d57c2cefd0b216c8ce5c251f618c3e931c732d0a/data/aft.csv")
```

This allows us to explicitly reference a version of the data so that any research we do can be precisely replicated by others. For instance, if you wanted to pull an old (and not yet cleaned-up) version of the `aft` dataset, you'd just need to go back in the GitHub history and run the following:

```{r old_aft, eval=FALSE, include=TRUE}
old_aft <- read_csv("https://raw.githubusercontent.com/j-hagedorn/trilogy/f0fb12d108734847114f17980b05686a26305e38/data/aat.csv")
```

# Summary Statistics

The table below shows the distinct count of motifs and tale types in *Trilogy* datasets. 

```{r overlaps}

x <- 
  atu_seq %>% 
  # Get all tale IDs and motif IDs within them
  select(motif,atu_id) %>% 
  mutate(in_atu_seq = T) %>%
  # Pull in all tale IDs present in annotated tales.
  # Note that counting motifs in annotated tales assumes 
  # that each tale has each motif in the canonical sequence.
  left_join(
    aft %>% select(atu_id) %>% mutate(in_aft = T),
    by = "atu_id"
  ) %>%
  distinct(motif, in_atu_seq, in_aft) %>%
  mutate(in_aft = if_else(is.na(in_aft),F,T)) %>%
  # Don't keep multiple rows per motif, count as present (i.e. 'TRUE')
  group_by(motif, in_atu_seq) %>%
  filter(in_aft == max(in_aft))

m <-
  tmi %>%
  select(motif = id) %>%
  distinct(motif) %>%
  left_join(x, by = "motif") %>%
  mutate(
    in_tmi = T,
    in_atu_seq = if_else(is.na(in_atu_seq),F,in_atu_seq),
    in_aft = if_else(is.na(in_aft),F,in_aft)
  ) 

m_sum <-
  m %>%
  summarise(
    in_tmi =     sum(in_tmi),
    in_atu_seq = sum(in_atu_seq),
    in_aft =     sum(in_aft)
  ) %>%
  mutate(unit = "motifs")
  
t <-
  atu_df %>%
  distinct(atu_id) %>%
  mutate(in_atu_df = T) %>%
  left_join(
    atu_seq %>% 
      distinct(atu_id) %>%
      mutate(in_atu_seq = T),
    by = "atu_id"
  ) %>%
  left_join(
    aft %>%
      distinct(atu_id) %>%
      mutate(in_aft = T),
    by = "atu_id"
  ) %>%
  mutate(
    in_atu_seq = if_else(is.na(in_atu_seq),F,in_atu_seq),
    in_aft = if_else(is.na(in_aft),F,in_aft)
  ) 

t_sum <-
  t %>%
  summarise(
    in_atu_df =  sum(in_atu_df),
    in_atu_seq = sum(in_atu_seq),
    in_aft =     sum(in_aft)
  ) %>%
  mutate(unit = "tale types")
  
m_sum %>%
  bind_rows(t_sum) %>%
  select(
    unit, tmi = in_tmi, 
    atu_df = in_atu_df, atu_seq = in_atu_seq, aft = in_aft
  ) %>%
  rmarkdown::paged_table()

rm(m); rm(m_sum); rm(t); rm(t_sum)

```

A few notes to help understand the relationship between these datasets:

-   Motifs do not exist in `atu_df`, because that dataset contains one row per `atu_id`. Similarly, tale types (`atu_id`s) do not exist in `tmi`, becuase that dataset contains one row per motif.
-   Not all `atu_id`s in `atu_df` are in `atu_seq`, because some of the tale summaries do not reference any motif IDs.^[E.g. ATU 1342: "*During a cold winter, a satyr (wood spirit) meets a man (boy) who is cold and accommodates him in his cave. The satyr watches the man blowing in his hand and is told that in this way he wants to warm his numb fingers. When the satyr serves up a meal, his guest blows on the food and explains that he wants to cool it. The satyr is afraid of this strange human behavior, blowing hot and cold in the same manner, and chases the man away.*"] This means that an `atu_id` can be present in `atu_df` and `aft`, but not in `atu_seq`, which means the text version of the tale cannot be referenced against an available list of motifs.

#### Intersections of Motifs within Trilogy Datasets

Below is an [upset plot](https://doi.org/10.1109/TVCG.2014.2346248) showing the intersection of discrete motifs across the various datasets which comprise the *Trilogy*.

```{r upset_motif}
library(UpSetR)
motif_lists <- 
  list(
    tmi = tmi %>% distinct(id) %>% .$id, 
    atu_seq = atu_seq %>% distinct(motif) %>% .$motif, 
    aft = x %>% filter(in_aft) %>% .$motif
  )
upset(
  fromList(motif_lists), 
  order.by = "freq",
  mainbar.y.label = "Intersection Size", 
  sets.x.label = "Motifs per Dataset"
)
rm(x); rm(motif_lists)
```

#### Intersections of Tale Types within Trilogy Datasets

```{r upset_types}
type_lists <- 
  list(
    atu_df = atu_df %>% distinct(atu_id) %>% .$atu_id, 
    atu_seq = atu_seq %>% distinct(atu_id) %>% .$atu_id, 
    aft = aft %>% distinct(atu_id) %>% .$atu_id
  )
upset(
  fromList(type_lists), 
  order.by = "freq",
  mainbar.y.label = "Intersection Size", 
  sets.x.label = "Tale Types per Dataset"
)
rm(type_lists)
```


```{r anti_joins}
un <-
  atu_seq %>% 
  select(motif) %>%
  distinct() %>%
  anti_join(tmi, by = c("motif" = "id"))

un <-
  aft %>%
  select(atu_id) %>%
  distinct() %>%
  anti_join(atu_seq %>% select(atu_id) %>% distinct(), by = "atu_id")
```

------------------------------------------------------------------------

# Motifs

The `tmi` is comprised of `r n_distinct(tmi$id)` distinct motifs.[^1] It is grouped into `r n_distinct(tmi$chapter_id)` chapters, including: *`r paste(unique(tmi$chapter_name), collapse = ", ")`*.

[^1]: Recall that Yarlott and Finlayson (2016) counted "46,248 motifs and sub-motifs, 41,796 of which have references to tales or tale types." While there is a difference, it is minimal, and it is unclear what they mean by sub-motifs.

## Hierarchy {.tabset .tabset-pills}

Under the chapter level, it has multiple nested levels of groups, which are named as follows:

-   `level_0` = What Thompson labelled 'Grand divisions', sections divisible by 100.
-   `level_1` = Smaller divisions end with '0', These are defined at intervals of 10.
-   `level_2`-`level_6` = Various sections with multiple layers of subdivisions

### Flat format

The excerpt below shows how this hierarchy structure is represented in the 'flat' dataset:

```{r, layout="l-body-outset"}
tmi %>%
  filter(level_2 == "B122") %>%
  select(chapter_id,id,motif_name,level,starts_with("level_")) %>%
  select(-level_5,-level_6) %>%
  arrange(id) %>%
  rmarkdown::paged_table()
```

------------------------------------------------------------------------

### Distribution by level

The most populated level of the index (i.e. '3') is that of the initial *subdivision*, indicating that there are frequently no splits made in the motif identified. While the index structure would allow for each subsequent level (i.e. levels 4 - 6+) to have increasing numbers of more finely grained motifs, these either do not exist or have not been filled in.

```{r}
tmi %>%
  ggplot(aes(x = level)) +
  geom_histogram(stat="count") +
  theme_minimal() + 
  theme(plot.title.position = "plot") +
  labs(
    title = "Most motifs are in the subdivisions",
    subtitle = "From chapters (level 0) through subdivisions (levels 3-6)",
    x = "Depth within index",
    y = "Distinct motif entries"
  )
```

------------------------------------------------------------------------

### Gaps

Note that some motifs are not fit into the hierarchical level format (i.e. `level = NA`). This occurs when there is a zero indicator at one of the decimal indices, since this creates a break in the hierarchical structure. For instance, in the "B122" section, we find B122.1 as a parent motif for B122.1.1-2, but there is no B122.0 to serve as a parent for B122.0.1.

The table below shows how many motifs (i.e. `n_motifs`) are in each chapter, and each level (*if you expand the row*).

```{r tmi_summary_tbl}
library(reactable)
tmi %>%
  group_by(chapter_name,level) %>%
  summarize(n_motifs = n_distinct(id)) %>%
  reactable(
    groupBy = c("chapter_name"),
    columns = list(
      level = colDef(
        aggregate = "count",
        format = list(
          aggregated = colFormat(suffix = " levels")
        )
      ),
      n_motifs = colDef(aggregate = "sum")
    )
  )
```

```{r}
summary_df <-
  tmi %>%
  group_by(chapter_id,chapter_name,level_0,level_1,level_2,level_3) %>%
  summarize(n = n()) %>% 
  ungroup() %>%
  left_join(tmi %>% select(id,level_0_name = motif_name), by = c("level_0" = "id")) %>%
  left_join(tmi %>% select(id,level_1_name = motif_name), by = c("level_1" = "id")) %>%
  left_join(tmi %>% select(id,level_2_name = motif_name), by = c("level_2" = "id")) %>%
  left_join(tmi %>% select(id,level_3_name = motif_name), by = c("level_3" = "id")) %>%
  select(
    starts_with("chapter_"),starts_with("level_0"),
    starts_with("level_1"),starts_with("level_2"),starts_with("level_3"),n
  )
```

------------------------------------------------------------------------

# Tale Types

------------------------------------------------------------------------

# Annotated Tales

-   Joining together data sets by primary key
-   First analysis: coverage of motif index in the tale type index
-   Visualization
-   Adding citations
-   Where to go next?

------------------------------------------------------------------------





n atu motifs not in tmi

n aft types not in atu

n motifs in tales

-   How many types vs motifs are in the ATU and the AFT? How many motifs are there in the TMI (answered)?
-   What's the percentage of motifs used in the ATU as contrasted with the TMI (answered)?
-   Given the 'type = motif string with equiprobable motifs in forkings' working hypothesis, 68245 strings as the answer is well, shocking, but that's it.
-   The next top ten variants seem to refer to the AFT, is that correct? The inserted image has some strange numbers though. First, what does n mean? Or, 46332, which is 1 more than 46331 in the column, which is 110 more than the number of motifs in the TMI?
-   Practically the same question about all the n values in the 2nd column for the top ten, reproducing the image.
-   How many percent of the TMI motifs (46222) are there in the AFT?
-   How many tale types are there in the AFT?
-   Based on the 2250 ATU type strings, how many possible strings (ways to tell a tale) exist? The suggested number, 68245, is beyond me, please explain your respective reasoning;
-   I cannot decode one of my slide titles, "ATU type combination network (4696 connections among x types)", does that ring a bell? Could x refer to the 2250 types?
-   average number of motifs which constitute a type -- the average number of forkings if they can be calculated
